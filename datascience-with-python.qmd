---
title: "Data Science with Python"
description: Documenting Data Science Ideas and Techniques
author: 
  name: Gideon Eshun
  url: mailto:fiiisnpires@gmail.com
format: 
  html:
    theme: 
      light: cosmo
      dark: darkly
    toc: true
    html-math-method: katex
title-block-banner: "#003865"
---

## Introduction to Data Science and Problem Solving

### Problem-Solving Skills

Data science is not just about working with data; it starts with a problem and the thinking process behind it. Organizations hire data scientists because they believe they have problems that data can address. At its core, data science is about problem-solving. While the tools and techniques used in data science evolve over time, the fundamental problem-solving skills remain the same.

For example, newer techniques like XGBoost often outperform older algorithms such as Decision Trees, though both serve the same purpose of making predictions based on data. What truly matters is the ability to think critically and approach problems with a willingness to learn.

Each phase of data science can be viewed as a problem-solving task. Defining the problem is the first challenge, as solving the wrong problem is a waste of time and resources. Problem definition determines what data needs to be collected. Collecting the right data in the appropriate amount is another problem that requires problem-solving skills. Analyzing the data to generate insights involves identifying patterns, trends, and relationships. For instance, a data scientist might analyze customer behavior to determine which products are frequently purchased together and use this insight for targeted marketing campaigns.

Python, our choice of programming language, is just one of the tools used to implement hypotheses about data. It's important to remember that the programming language or tool is secondary to the analytical thinking and problem-solving skills that drive data science projects.

#### Critical Thinking

Problem-solving in data science involves breaking down complex problems into smaller, manageable parts. This helps in identifying key issues and developing focused strategies. Critical thinking plays a crucial role in this process by evaluating information and making judgments. After defining the problem, one must:

-   Brainstorm possible solutions.

-   Evaluate them.

-   Select the best one.

Critical thinking helps in understanding the assumptions and limitations of different solutions and models, guiding the selection of the most suitable one based on available evidence.

### The Analyst's Reductionist Approach

An analyst, even if not working directly with data, employs a reductionist view to find underlying elements. When the resource being analyzed is data, this person becomes a data analyst. However, analysts also need a synthetic or system approach to understand why certain data is produced, which involves considering the bigger picture and engaging with stakeholders and subject-matter experts.

Analytical thinking involves understanding the building blocks or fundamentals and then constructing complex expressions from them. In programming, for instance, data types and operators are the basic building blocks. Understanding these primitives allows one to build more advanced computations. Similarly, in data science, understanding the basics of business need, data manipulation and analysis is crucial for creating sophisticated models and solutions.

Science often uses models to represent real-world phenomena, employing a reductionist approach to simplify complex realities. In data science, this can be seen in machine learning, where models are functions that take data as input and provide predictions as output. This approach allows for understanding and inferring real-world behaviors through simplified representations.

Data analysis does not start with analysis but with synthesis. This involves understanding the context of the project and how it fits into the bigger picture. It's essential to grasp the business problem that needs to be solved and the value it brings to the organization. Knowing the project's context helps ensure that the analysis aligns with the business goals and addresses the right issues.

### Identifying the Problem to Solve

A data scientist must clearly understand the business goal that the analysis will address. For instance, the goal might be to increase revenue or save costs. Ultimately, businesses are focused on financial outcomes or that which gives competitive advantage, so even time-saving measures should be translated into monetary value. Defining the value the data science project will bring to the business can convince business leaders to buy into the project.

#### Asking the Right Questions

To effectively address the business goal, asking the right questions is crucial. If the goal is to increase revenue, some pertinent questions might include:

-   What are the factors influencing revenue?

-   Which products and services are most profitable?

-   How can we optimize our operations to boost profitability?

-   What customer behaviors drive the most sales?

By asking these questions, data scientists can focus their analysis on areas that will have the most significant impact on the business, ensuring that their efforts are aligned with the organization's objectives.

### The Necessity of Integrating Programming, Software Engineering, Business Knowledge, and Data Science

#### Integration of Diverse Skill Sets

Learning programming, software engineering, business knowledge, and data science together is essential because these areas are interdependent in practical applications. In the real world, data scientists must write and debug code, understand software engineering principles to build scalable and efficient systems, and apply business knowledge to ensure their analyses are relevant and actionable. By integrating these disciplines, learners gain a holistic skill set that allows them to approach problems comprehensively and develop solutions that are both technically sound and aligned with business objectives.

#### Real-World Application and Relevance

Integrating these diverse fields keeps learning grounded in real-world scenarios. For instance, when developing a machine learning model, you need programming skills to implement the algorithm, software engineering knowledge to ensure the solution is robust and maintainable, and business acumen to understand the problem context and measure success. This approach ensures that theoretical concepts are immediately applied in practical situations, reinforcing learning and demonstrating the direct impact of each skill on real-world challenges.

#### Comprehensive Problem-Solving

Combining programming, software engineering, business knowledge, and data science fosters a problem-solving mindset that is crucial in today's data-driven world. It prepares learners to tackle complex, multifaceted problems by leveraging the strengths of each discipline. For example, a data scientist who understands business strategy can better prioritize projects and communicate findings, while software engineering skills enable them to deploy their models effectively. This comprehensive approach not only enhances individual capabilities but also leads to the development of innovative, data-driven solutions that drive business success.

## Introduction to Python Programming

Consider this analytic scenario:

> Between the years `2016` and `2020`, $KN^4$ company recorded the following revenues (in CAD): `12000, 23000, 15000, 10000, 18000` respectively. How do you help $KN^4$ understand if it's `2021` revenue is in line with historical revenues?

### Python as calculator

Currently, we do not know the revenue for 2021. One approach would be to compare it with the revenue from 2020 to determine if it falls short or exceeds by a certain percentage. This approach assumes that the most recent value is a good indicator of future performance.

However, relying solely on the 2020 revenue does not take into account the overall trend from previous years. To make a more informed comparison, we need a single representative number that combines all historical revenues. This can be achieved by calculating the mean (average) of the revenues from 2016 to 2020.

To determine the mean (average) revenue for $KN^4$ from 2016 to 2020, we use the following calculation:

```{python}
#| eval: false

(12000 + 23000 + 15000 + 10000 + 18000) / 5
# Output: 15600.0
```

If you were able to type this out and see a result, congratulations! You just wrote an expression that Python can interpret. Let's break down this expression to understand how Python processes it:

-   **Numbers:** Python recognizes `12000`, `23000`, `15000`, `10000`, and `18000` as integers (whole numbers).

-   **Operators:** The plus sign `+` is an arithmetic operator for addition, and the forward slash `/` is for division.

-   **Parentheses:** The parentheses `()` group the expressions, instructing Python to first add the integers and then divide the sum by another integer.

Here is how Python interprets this expression:

1.  **Addition:** Python adds the numbers together inside the parentheses: $12000 + 23000 + 15000 + 10000 + 18000 = 78000$

2.  **Division:** Python then divides the sum by 5: $\frac{78000}{5} = 15600.0$

Notice the result is `15600.0`, a number with a decimal point. Python calls this type of number a `float`, short for floating-point number. Floats allow us to deal with numbers that have fractional components, such as `3.142`.

Using parentheses helps ensure the correct order of operations. For example, omitting the parentheses in our original expression would result in a different calculation:

$$12000+23000+15000+10000+18000/5=63600.0$$

This incorrect result occurs because Python performs the division first ($18000 / 5 = 3600.0$) and then adds the other numbers ($12000 + 23000 + 15000 + 10000 + 3600.0 = 63600.0$).

By correctly using parentheses, we ensure that the addition is performed before the division, yielding the correct mean revenue.

In Python, every object has a data type, which defines how you can interact with it:

-   **Integers (`int`):** Whole numbers without a fractional component, e.g., `12000`.

-   **Floating-point numbers (`float`):** Numbers with a fractional component, e.g., `15600.0`.

Python correctly performs the addition `+` and division `/` operations on our numbers because it recognizes the context in which these operators are used. It's important to note that `+` and `/` are not the only arithmetic operators in Python. Other operators include `-` (subtraction), `*` (multiplication), and `%` (modulus) etc. Python follows the mathematical order of operations (PEMDAS/BODMAS). Without parentheses, the division would be performed before the addition, leading to an incorrect result.

### Using Variables for Persistence

When we perform computations, the results are often stored temporarily in memory. To use the result later, we need to assign it to a variable. This practice allows us to reference the computed value without recalculating it each time.

```{python}
#| eval: false  

mean_revenue = (12000 + 23000 + 15000 + 10000 + 18000) / 5
```

In this example, we calculate the arithmetic mean of the revenues and store it in a variable called `mean_revenue`. The variable name should be descriptive, helping you understand its purpose and content.

The assignment operator `=` assigns the value on the right-hand side (RHS) to the variable on the left-hand side (LHS). It's important to distinguish this from the equality operator `==`, which checks if two values are equal. Here, Python computes the expression on the RHS and assigns the resulting value to `mean_revenue`.

Remember the integer division `//` that returns an integer after dividing two numbers? A more general way to force a numeric value like `mean_revenue` (which is a float) to be an integer is by casting it by wrapping it in `int` constructor function. Here, we are accessing the value of our geometric mean by using the variable name.

```{python}
#| eval: false  

int(mean_revenue) 
# Output: 14943
```

This will return the integer part of `mean_revenue`, effectively discarding any fractional component.

**Variable Naming Rules**

Python has specific rules for naming variables:

-   Variable names must start with a letter (`a-z, A-Z`) or an underscore (`_`).

-   Subsequent characters can include letters, digits (`0-9`), or underscores.

-   Variable names are case-sensitive (`mean_revenue` and `Mean_Revenue` are different variables).

**Summary**

Understanding how to persist values using variables is crucial in Python programming. It allows you to store and reuse computed values efficiently. By following naming conventions and leveraging assignment operators, you can manage data effectively and make your code more readable.

### Arithmetic Mean as a Linear Combination

The method we used to compute the mean in our previous example gives us the arithmetic mean. We summed up all the historical revenues and, since we have five years of data, we divided the total by 5. This can be mathematically expressed as:

$$\frac{1}{5}(12000 + 23000 + 15000 + 10000 + 18000) \\ = \frac{1}{5}(12000) + \frac{1}{5}(23000) + \frac{1}{5}(15000) + \frac{1}{5}(10000) + \frac{1}{5}(18000)$$

```{python}
#| eval: false

0.2*12000 + 0.2*23000 + 0.2*15000 + 0.2*10000 + 0.2*18000
# Output: 15600.0
```

Thus, our new number (`15600.0`) is formed by taking one-fifth of each of the historical revenues and summing them up. Each historical revenue contributed to the new number by being scaled down by $\frac{1}{5} = 0.2$. Formally, this process is known as creating a linear combination of the historical revenues.

### The Concept of Linear Combination

A linear combination involves only two operations: multiplication by a scalar and the addition of terms. This concept is fundamental to many models used in data analysis, such as linear regression. When we use equal weights (scale factors) for each revenue, we are calculating the arithmetic mean. However, if we use different weights, we calculate a weighted mean.

The scale factor used in the arithmetic mean is intentionally chosen to be the inverse (reciprocal) of the number of items you are summing, $\frac{1}{n}$​. Mathematically, the arithmetic mean can be represented as:

$$\frac{1}{n}\sum_{i=1}^{n}x_i = \frac{\sum_{i=1}^{n}x_i}{n} = \frac{x_1+x_2+\dots+x_{n-1}+x_n}{n}$$

In linear algebra terms, this is akin to finding the dot product of a weight vector and a revenue vector. Essentially, we are extracting features from the revenue vector, and in this case, the feature is a single number that represents the average revenue.

$$w\cdot v = \vec{w}^{\intercal}\vec{v} = \sum_{i = 1}^{n}w_iv_i = w_1v_1 + w_2v_2 + \dots + w_nv_n$$

```{python}
#| eval: false

weights = [0.2] * 5 
revenues = [12000, 23000, 15000, 10000, 18000]

sum([weight * rev for weight, rev in zip(weights, revenues)])
# Output: 15600.0
```

### Benefits of Linear Models

Linear models, like the arithmetic mean, are easy to project or extrapolate. Since they follow a linear relationship, they can be extended to unseen data simply by continuing the line (or hyper-plane). Additionally, linear models are:

-   **Easy to understand:** Their simplicity makes them accessible for explanation and interpretation.

-   **Simple to train and deploy:** Linear models often require less computational power and time compared to more complex models.

By understanding these fundamental concepts, you can effectively utilize Python and linear combinations to analyze and interpret data, providing valuable insights for your organization.

### Another Kind of Mean

In our previous example, we chose to linearly combine our historical revenues to compute the arithmetic mean. However, there are other ways to aggregate historical records to derive a new value. One such method is the geometric mean, which involves finding the product of all the revenues and then taking the nth root (where n is the number of revenues).

For our revenues, the geometric mean can be computed as follows:

```{python}
#| eval: false

(12000 * 23000 * 15000 * 10000 * 18000) ** (1/5)
# Output: 15543.045
```

This method provides us with a different value compared to the arithmetic mean, but it still gives us a useful number to compare against our 2021 revenue. The mathematical representation of the geometric mean is:

$$
\left(\prod_{i = 1}^{n}x_i\right)^{\frac{1}{n}} = \sqrt[n]{x_1\times\dots\times x_{n-1}\times x_n}
$$

Another type of mean is the harmonic mean, which is useful when dealing with rates or ratios. To calculate the harmonic mean of our revenues, we use the following formula:

$$\frac{n}{\sum_{i=1}^{n}\frac{1}{x_i}} = \frac{n}{\frac{1}{x_1}+\frac{1}{x_2}+\dots+\frac{1}{x_{n-1}}+\frac{1}{x_n}}$$

In Python, we can compute it as follows:

```{python}
#| eval: false

5 / ((1/12000) + (1/23000) + (1/15000) + (1/10000) + (1/18000))
# Output: 14163.415
```

### Comparing the Means

Let's compare the arithmetic, geometric, and harmonic means:

-   **Arithmetic Mean (Am)**: `15600.0`

-   **Geometric Mean (Gm)**: `15543.04`

-   **Harmonic Mean (Hm)**: `14163.415`

These three means provide different perspectives on the data. The arithmetic mean is influenced by extreme values, while the geometric mean mitigates the impact of outliers by using multiplication and roots. The harmonic mean is most appropriate for rates or ratios.

Interestingly, there's a relationship between the three means. In general, for positive numbers, the following inequality holds:

$$Hm \leq Gm \leq Am$$

Additionally, there is a relationship involving the geometric mean, harmonic mean, and arithmetic mean:

$$Gm = \sqrt{Hm \times Am}$$

​While there is a slight discrepancy due to rounding and floating-point precision, the relationship generally holds.

### Understanding Floating-Point Arithmetic

In Python, floating-point numbers are approximations, which can lead to unexpected results in calculations:

```{python}
#| eval: false

0.2 + 0.2 + 0.2 == 0.6  # Output: False
```

This occurs because the internal representation of floating-point numbers may introduce small errors. When performing arithmetic operations, these tiny discrepancies can accumulate, leading to results that are slightly off from the exact mathematical value.

### What We've Learned About Python

So far, we've covered basic Python syntax and arithmetic operators such as addition (`+`), division (`/`), multiplication (`*`), and exponentiation (`**`). We also encountered different data types: our revenues are integers (e.g., `12000`), while the result of our mean calculations is a float (e.g., `15600.0`), indicated by the presence of a decimal point.

You can verify data types using the `type()` function in Python:

```{python}
#| eval: false

type(12000)  # Output: <class 'int'>
type(15600.0)  # Output: <class 'float'>
```

If we want the arithmetic mean to be an integer, we can use integer division (`//`) operator:

```{python}
#| eval: false

(12000 + 23000 + 15000 + 10000 + 18000) // 5
# Output: 15600
```

Understanding syntax, operators, and data types forms the foundation of programming in Python. With this knowledge, we can build more complex code and apply analytical methods to solve various problems.

### What We've Learned About Data Science

**Summarization and Central Tendency**

In data science, it's often more effective to summarize a set of numbers with a single representative value. This approach simplifies communication and interpretation. One common method for summarizing data is by calculating the mean. However, choosing the right type of mean---arithmetic, geometric, harmonic, or another---depends on the context and the nature of the data.

**Choosing the Right Mean**

Selecting the appropriate mean requires critical thinking and depends on several factors:

1.  **The Nature of the Data Generation Process**:

    -   If the process is additive, such as daily temperatures, the arithmetic mean is suitable.

    -   If the process is multiplicative or involves compounding effects, such as interest rates or investment returns, the geometric mean is more appropriate.

2.  **Characteristics of the Data Points**:

    -   The presence of outliers can significantly influence the arithmetic mean, making it less representative of the central tendency. In such cases, alternative measures like the median or trimmed mean might be more appropriate.

3.  **Business Objectives and Context**:

    -   The specific goals of the analysis can dictate the choice of mean. For example, understanding average growth rates over time for financial planning would benefit from using the geometric mean.

**Understanding Data Reduction**

Reducing a set of numbers to a single value while retaining as much relevant information as possible is a fundamental aspect of data science. This reductionist approach simplifies analysis and communication but requires careful consideration to avoid significant loss of information. The chosen summarization method should provide meaningful insights and align with the underlying data characteristics and business needs.

**Geometric Mean and Interactions**

The geometric mean's ability to account for interactions between values makes it particularly valuable in scenarios where values influence each other over time. For example, in investments, the growth of a portfolio in one year may affect its growth in subsequent years. This interaction is why the geometric mean is preferred for such cases, as it captures the compounding effect.

**Harmonic Mean in Machine Learning**

1.  **F1 Score**:

    -   **Combining Precision and Recall**: The F1 score, which is the harmonic mean of precision and recall, is a widely used metric in classification tasks. It provides a single measure of a model's performance by balancing the trade-off between precision and recall. $F1 = 2 \times \frac{\text{Precision} \times \text{Recall}}{\text{Precision} + \text{Recall}}$​

    -   **Why Harmonic Mean**: The harmonic mean is used because it penalizes extreme values more than the arithmetic mean, ensuring that a model with high precision but low recall (or vice versa) does not achieve a high $F1$ score. This makes it a robust metric for imbalanced classification problems.

**Summary**

In conclusion, understanding the context and characteristics of your data is crucial in selecting the appropriate method for summarization. Whether using the arithmetic, geometric, or harmonic mean, each has its place in data analysis. Critical thinking and a clear understanding of the data generation process, the nature of the data, and the business objectives will guide you in making the right choice. This approach ensures that your summarization retains the most relevant information and provides valuable insights.

### Comparison Operator

Suppose we are informed that the revenue for 2021 is `16000`. We can compare this with our mean of the historical revenues to determine if they are equal. To test for equality, we use the double equal sign (`==`), as shown below:

```{python}
#| eval: false

mean_revenue == 16000
# Output: False
```

This statement checks if the value on the left-hand side (LHS) is equal to the value on the right-hand side (RHS). The result is a Boolean value, which can be either `True` or `False`. You can verify the data type of a value using the `type()` function.

It is important to note that `==` is a comparison operator, while `=` is an assignment operator. Comparison operators are essential for setting conditions in programming logic. Here's an example of testing for inequality:

```{python}
#| eval: false

mean_revenue != 16000  # opposite of equality
# Output: True
```

**To Do**

What operators would you use to check if a value is less than or equal to another?

```{python}

```

### If Statement

The company $KN^4$ considers revenue greater than the historical average as desirable. We can test if the 2021 revenue is greater than the mean of the historical revenues using an `if` statement, which allows us to make decisions in our code.

The structure of an `if` statement is as follows:

```{python}
#| eval: false

if condition_is_true:
    code_block_specifying_what_to_do
```

We start with the `if` keyword, provide a test condition that results in a Boolean value, and end with a colon. The next line, which is indented, contains the code to be executed if the condition is true. Python uses indentation to define a block of code.

Here is an example:

```{python}
#| eval: false

if 16000 > mean_revenue:
    print('above typical revenue')
# Output: above typical revenue
```

In this case, we want to print "above typical revenue" if our 2021 revenue is greater than the historical mean. If you change the comparison operator to less than, the print statement will not execute because the condition `16000 < mean_revenue` is not true.

```{python}
#| eval: false

if 16000 < mean_revenue:
    print('below typical revenue')
else:
    print('above typical revenue')
# Output: above typical revenue
```

The `else` statement specifies what happens when the condition in the `if` statement is false. Note that the `else` part does not take a condition; it simply executes the code block when the `if` condition is not met.

What good is `if-else` construct if you intend returning a bool? Instead of

```{python}
#| eval: false

if 16000 > mean_revenue:
    True
else:
    False
# Output: True
```

one can just do:

```{python}
#| eval: false

16000 > mean_revenue
# Output: True
```

#### Ternary Operator

Python offers a concise way to write `if-else` statements using the ternary operator. This one-liner syntax is especially useful for simple conditional expressions, making your code more readable and succinct.

The syntax for the ternary operator is as follows:

```{python}
#| eval: false

[result_when_true] if [condition] else [result_when_false]
```

Here's an example that compares the 2021 revenue with the historical mean:

```{python}
#| eval: false

'below typical revenue' if 16000 < mean_revenue else 'above typical revenue'
# Output: above typical revenue
```

In this example, the expression evaluates to `'below typical revenue'` if `16000` is less than `mean_revenue`; otherwise, it evaluates to `'above typical revenue'`.

This form of the ternary operator can simplify your code when dealing with straightforward conditional checks. For more complex conditions or multiple actions, it's better to use the standard `if-else` statement to maintain readability and clarity.

Complex conditions can also be specified. The only requirement is that they evaluate to a Boolean value:

```{python}
#| eval: false

if 14000 <= mean_revenue < 18000:
    print('within range')
# Output: within range
```

**Summary**

In summary, the `if-else` construct is a powerful tool in Python for decision-making based on conditions. It helps you execute specific code blocks depending on whether a condition is true or false. Additionally, we introduced the string data type in Python, which is used for text and can be created by wrapping the value with either single `'` or double `"` quotes.

By understanding and applying these concepts, you can make your Python code more dynamic and responsive to different data conditions.

### Sequencing Structures and Collections

So far, we've referred to individual revenues. Now, let's consider these revenues as a sequence (an array of items) instead of individual entries. This means we need to choose a data structure that supports treating all the revenues as a group. Python provides several options, but we will use a list. A list in Python is defined by enclosing items in square brackets, separated by commas. Using a list literal, elements are enclosed in square brackets and separated by commas.

```{python}
#| eval: false

revenues = [12000, 23000, 15000, 10000, 18000]
```

Alternatively, you can use the list constructor:

```{python}
#| eval: false
revenues = list((12000, 23000, 15000, 10000, 18000))
```

The list constructor takes an iterable object, which we will discuss later. Lists can be heterogeneous, meaning they can contain a mix of data types, although some built-in functions might not work on heterogeneous lists. A list is a container for other data types (int, str, float, bool) or even other containers. They are *mutable*, *ordered*, and *iterable*.

> A data structure is an implementation offered by the programming language to efficiently store and retrieve data from the computer's memory. It determines how data is organized in memory, aiming to use less space and reduce retrieval time. Data structures can contain any data type or another data structure. The security of data in memory also varies (for example, a tuple is immutable and hence more secure than a list, which is mutable).

Using a sequencing data structure like a list to store our revenues provides several advantages. We can use Python's built-in functions that operate on iterable objects. Two commonly used functions are `sum` (which adds up the numbers in the list) and `len` (which finds the number of items in the list). With these two functions, we can compute the arithmetic mean as follows:

```{python}
#| eval: false

average_revenue = sum(revenues) / len(revenues)
```

To check if the company has recorded a revenue of 16000 in the past, we use the `in` containment operator. Without this, we would need to use an equality operator to compare each historical revenue with 16000.

```{python}
#| eval: false

16000 in revenues # Output: False

# Opposite of checking if 16000 is in the list
16000 not in revenues  # Output: True
```

Here's an example of a list with a mix of data types, illustrating that certain built-in functions may not work on heterogeneous lists:

```{python}
#| eval: false

revenues_mix = [12000, 23000, 15000, 10000, 18000, '16000']
# max(revenues_)  # This will raise an error
```
